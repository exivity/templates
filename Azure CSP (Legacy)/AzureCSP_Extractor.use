## Global variables
# Your CSP domain, usually xxxx.onmicrosoft.com
public var MyDomain = "xxxx.onmicrosoft.com"
# Make sure to set this to your CSP currency (3 character ISO currency code)
public var currency = "EUR"
# Make sure to set this to your CSP region (2 character ISO country code)
public var region = "NL"
# Legacy Azure CSP charge start date (can be found on invoice)
public var csp_charge_startday = "01"
# Application ID of the Partner Center Web Application
public var client_id = "<Client-ID>"
# Secret that belongs to the client application GUID
public encrypted var secret = "<Client-Secret>"
# If using internal usage, specificy IUR GUID 
public var IUR_id = "<Internal-Usage-Subscription-GUID>"
# Should I collect Azure Usage (yes/no)
public var Collect_Azure_usage = "yes"
# Should I collect Azure Plan (yes/no) 
public var Collect_Azure_plan = "yes"
# Should I collect IUR Subscriptions (yes/no)
public var Collect_Azure_IUR_Subscription = "no"
# Should I collect IUR Usage (yes/no)
public var Collect_Azure_IUR_Usage = "no"
# Should I collect te Ratecard (yes/no)
public var Collect_Azure_ratecard = "yes"
# Should I collect the Invoice (yes/no)
public var Collect_Azure_invoice = "yes"

## Default variables
# Set loglevel
loglevel INFO

# Standard location for writing extracted files, relative to %EXIVITY_HOME_PATH%
var exportdir = "system/extracted/${MyDomain}/AzureCSP"
# Overwrite the invoice if necessary
var overwrite_invoice = no

# Make sure that the IUR Usage extractor never runs out of subscriptions
if (${Collect_Azure_IUR_Usage} == yes) {
	var Collect_Azure_IUR_Subscription = yes
}

# Define today and tomorrow dates
var today = ${ARG_1}
var tomorrow = ${ARG_2}

## Check passed arguments
gosub check_dateargument(${today})
gosub check_dateargument(${tomorrow})

# Collect subscriptions from online source or local files
var online_subscriptions = yes

# Define Partnerroot
var partnerroot = "https://api.partnercenter.microsoft.com"

# Encode items for token
uri encode-component client_id
uri encode-component secret
uri encode-component IUR_id

#
#=================  End Configuration ==================#






print "------------------------------------------------"
# Get how many days the loop must run
gosub get_loopcount (${ARG_1}, ${ARG_2})

var input_date = ${ARG_1}

loop date_range ${loopcount} {

	var datadate = ${YEAR}${MONTH}${DAY}

	# Define current rundate
	var rundate = ${input_date}

	# Setup next date
	var input_date = (@DTADD(${rundate}, 1, DAY))

	var next_date = ${rundate}

	var next_date = (@DTADD(${next_date}, 1, DAY))

	var oldstoredate = (@DTADD(${rundate}, -1, MONTH))

	match a "^([0-9]{8})" ${rundate}
    var rundate = ${a.RESULT}

	#format ${rundate} outputs are ${day}, ${month}, ${year}
	gosub format_date (${rundate})
	var storeday = ${day}
	var storemonth = ${month}
	var storeyear = ${year}

	#format ${oldstoredate} outputs are ${day}, ${month}, ${year}
	gosub format_date (${oldstoredate})
	var oldstoreyear = ${year}

	if ("${csp_charge_startday}" > "${storeday}") {
		var storemonth = (${storemonth}-1)
		match numberfilter "^([^\d]{2}|\d[^\d]|[^\d]\d|.|.{3})$" ${storemonth}
		if (${numberfilter.STATUS} == MATCH) {
			var storemonth = 0${storemonth}
			if ("${storemonth}" == "00") {
				var storemonth = 12
				var storeyear = ${oldstoreyear}
			}
		}
	}

    #Define actual old month
    var literal_old_month = (${MONTH}-1)
    match numberfilter "^([^\d]{2}|\d[^\d]|[^\d]\d|.|.{3})$" ${literal_old_month}
    if (${numberfilter.STATUS} == MATCH) {
        var literal_old_month = 0${literal_old_month}
        if ("${literal_old_month}" == "00") {
            var literal_old_month = 12
        }
    }

	# Define loop dates
	## Get yesterday as this does not yet exist
	var lastdate = (@DTADD(${rundate}, -1, DAY))

	## Format yesterday outputs are ${day}, ${month}, ${year}
	gosub format_date (${lastdate})
	var previous_day = ${day}
	var previous_month = ${month}
	var previous_year = ${year}

	## Format today outputs are ${day}, ${month}, ${year}
	gosub format_date (${rundate})
	var this_day = ${day}
	var this_month = ${month}
	var this_year = ${year}

	## Format tomorrow outputs are ${day}, ${month}, ${year}
	gosub format_date (${next_date})
	var next_day = ${day}
	var next_month = ${month}
	var next_year = ${year}

	# Setup API request date/time
	var start_time = "${this_year}-${this_month}-${this_day}T00:00:00"
	var end_time = "${next_year}-${next_month}-${next_day}T00:00:00"

	# Create knowledge about previous bukkit
	var previousbukkit_date = (@DTADD(${rundate}, -29, DAY))
	gosub format_date (${previousbukkit_date})
	var previousbukkit_month = ${month}
	var previousbukkit_year = ${year}
	
	# Define month offset to actual month
	var basedate = (@CURDATE("%Y%m"))
	var basedate = "${basedate}01"
	var requestdate = ${storeyear}${storemonth}"01"

	var offset = ((@DATEDIFF(${basedate}, ${requestdate}))/30.436875)
	var offset = (@ROUND("${offset}",0))
	#var offset = (${offset}-1)
		
	# Define bukkits
	var previousbukkitdir = "${exportdir}/${previousbukkit_year}/${previousbukkit_month}"
	var bukkitdir = "${exportdir}/${storeyear}/${storemonth}"
	print "|Date||||| ${rundate}"
	print "|Bukkit||| ${bukkitdir}"

	if (${Collect_Azure_usage} == yes) {
		print "|Running|| Azure Usage collection"
		# Azure Usage path variables
		var customer_export_file = "${bukkitdir}/AzureUsage/${rundate}_csp_customers.csv"
		var subscriptions_export_file = "${bukkitdir}/AzureUsage/${rundate}_csp_subscriptions.csv"
		var usage_export_file = "${bukkitdir}/AzureUsage/${rundate}_csp_usage.csv"
		var json_filedir = "${bukkitdir}/AzureUsage/json"

		# Setup Azure Custommers CSV
		csv "customers" = "${customer_export_file}"
		csv add_headers "customers" ID tenantId Name Domain Type Relationship
		csv fix_headers "customers"
	
		# Setup Azure Subscription CSV
		csv "subscriptions" = ${subscriptions_export_file}
		csv add_headers "subscriptions" customer_id tenant_id companyName subscription_id offerId offerName friendlyName quantity unitType creationDate effectiveStartDate commitmentEndDate status autoRenewEnabled billingType contractType
		csv fix_headers "subscriptions"

		# Setup Azure Usage CSV
		csv "usage" = ${usage_export_file}
		csv add_headers "usage" customer_id subscription_id usageStartTime usageEndTime
		csv add_headers "usage" resource_id resource_name resource_category resource_subcategory
		csv add_headers "usage" quantity unit resourceUri location partNumber orderNumber objectType Parent ExtraCosts TenantSpecificCosts region
		csv fix_headers "usage"

		# Get the authtoken, output is ${access_token}
		gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})
	
		# Get list of customers
		clear http_headers
		set http_header "Accept: application/json"
		set http_header "Authorization: Bearer ${access_token}"	
		set http_savefile "${json_filedir}/${rundate}_customers_0.json"
		buffer customers = http GET "${partnerroot}/v1/customers"
		if (${HTTP_STATUS_CODE} != 200) {
			gosub write_http_error (${HTTP_STATUS_CODE})
		}

		# Loop through customer batches till all customers are fully processed
		loop customers_loop {
			# Iterate through the customers
			foreach $JSON{customers}.[items] as this_customer {
				# Write customer data to CSV
				csv write_field customers $JSON(this_customer).[id]
				csv write_field customers $JSON(this_customer).[companyProfile].[tenantId]
				csv write_field customers $JSON(this_customer).[companyProfile].[companyName]
				csv write_field customers $JSON(this_customer).[companyProfile].[domain]
				csv write_field customers $JSON(this_customer).[attributes].[objectType]
				csv write_field customers $JSON(this_customer).[relationshipToPartner]

				# Define some arguments for subscription extraction
				var companyname = $JSON(this_customer).[companyProfile].[companyName]
				var customerid = $JSON(this_customer).[id]
			
				
				loop requestsubcription {

					# Get the authtoken, output is ${access_token}
					gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})
					# Setup headers with tollerance for http request to the subscription
					clear http_headers
					set http_header "Accept: application/json"
					set http_header "Authorization: Bearer ${access_token}"
					set http_retry_count 5
					set http_retry_delay 30000
					buffer subscriptions = http get ${partnerroot}/v1/customers/${customerid}/subscriptions

					if (${HTTP_STATUS_CODE} == 200) {
						save {subscriptions} as "${json_filedir}/${rundate}_subs_${customerid}.json"
						exit_loop
					} else {
						save {subscriptions} as "${json_filedir}/exclusions/${rundate}_subs_${customerid}.json"
						exit_loop
					}
				}


				

				
				# Define certain variables for the reseller filters
				var reseller_code = $JSON{subscriptions}.[code]
				var Count = $JSON{subscriptions}.[totalCount]

				# Filter reseller codes
				if (("${reseller_code}" != 20002) && ("${reseller_code}" != 3000) && ("${reseller_code}" != "") && ("${reseller_code}" != "EXIVITY_INVALID_JSON") && (${Count} != 0) && ("${Count}" != "EXIVITY_INVALID_JSON") && ("${Count}" != "EXIVITY_NOT_FOUND")) {
                	# Iterate through the subscriptions
					foreach $JSON{subscriptions}.[items] as this_subscription {
						# Define the offername for a filter
                        var offername = $JSON(this_subscription).[offerName]

						# Write subscriptiondata to CSV
						csv write_field subscriptions ${customerid}
						csv write_field subscriptions $JSON(this_customer).[companyProfile].[tenantId]
						csv write_field subscriptions $JSON(this_customer).[companyProfile].[companyName]
						csv write_field subscriptions $JSON(this_subscription).[id]
						csv write_field subscriptions $JSON(this_subscription).[offerId]
						csv write_field subscriptions ${offername}
						csv write_field subscriptions $JSON(this_subscription).[friendlyName]
						csv write_field subscriptions $JSON(this_subscription).[quantity]
						csv write_field subscriptions $JSON(this_subscription).[unitType]
						csv write_field subscriptions $JSON(this_subscription).[creationDate]
						csv write_field subscriptions $JSON(this_subscription).[effectiveStartDate]
						csv write_field subscriptions $JSON(this_subscription).[commitmentEndDate]
						csv write_field subscriptions $JSON(this_subscription).[status]
						csv write_field subscriptions $JSON(this_subscription).[autoRenewEnabled]
						csv write_field subscriptions $JSON(this_subscription).[billingType]
						csv write_field subscriptions $JSON(this_subscription).[contractType]

                        

                        # Filter for the Microsoft Azure offers
                        if ("${offername}" == "Microsoft Azure") {
                            var subscriptionid = $JSON(this_subscription).[id]
							#print "Testing SUBID: ${subscriptionid} for usage items"

                            # Setup a usage continuation variable for large subscriptions
                            var continuationToken = none
                            
                            # Setup a records counter to keep track of the amounts
                            var totalrecords = 0

                            # Loop through usage items and collect continuation items if needed
                            loop usageloop {
                            # Run a extraction for up to 1000 usage lineitems
                                if (${usageloop.COUNT} == 1) {
									#print "Runnning first usage extraction"
                                    # Run te first extraction of up to 1000 items starting with a daily report
                                    # Get the authtoken, output is ${access_token}
									gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})
									# Setup headers with tollerance for http request to the subscription
									set http_retry_count 5
									set http_retry_delay 30000
									clear http_headers
                                    set http_header "Accept: application/json"
                                    set http_header "Authorization: Bearer ${access_token}"
                                    buffer usage = http GET "${partnerroot}/v1/customers/${customerid}/subscriptions/${subscriptionid}/utilizations/azure?start_time=${start_time}&end_time=${end_time}&granularity=daily&showDetails=true"

									if (${HTTP_STATUS_CODE} == 200) {
										save {usage} as "${json_filedir}/${rundate}_usage_${customerid}_${subscriptionid}_${usageloop.COUNT}.json"
									} else {
										save {usage} as "${json_filedir}/exclusions/${rundate}_usage_${customerid}_${subscriptionid}_${usageloop.COUNT}.json"
									}
									
                                    # Define if there are items in the daily report
                                    var totalCount = $JSON{usage}.[totalCount]

                                    # When the report is empty run for an hourly report
                                    if (${totalCount} == "EXIVITY_NOT_FOUND") {
                                        # Collect Hourly report
                                        buffer usage = http GET "${partnerroot}/v1/customers/${customerid}/subscriptions/${subscriptionid}/utilizations/azure?start_time=${start_time}&end_time=${end_time}&granularity=hourly&showDetails=true"
										if (${HTTP_STATUS_CODE} == 200) {
											save {usage} as "${json_filedir}/${rundate}_usage_${customerid}_${subscriptionid}_${usageloop.COUNT}.json"
										} else {
											save {usage} as "${json_filedir}/exclusions/${rundate}_usage_${customerid}_${subscriptionid}_${usageloop.COUNT}.json"
										}
                                    }
                                } else {
                                    # This is a latter run so the continuation token is required
									###### COPY FROM ORIGINAL? ######
                                    set http_retry_count 5
                                    set http_retry_delay 30000
                                    clear http_headers
                                    set http_header "Accept: application/json"
                                    set http_header "Authorization: Bearer ${access_token}"
                                    set http_header "MS-ContinuationToken: ${continuationToken}"
                                    set http_savefile "${json_filedir}/${rundate}_usage_${customerid}_${subscriptionid}_${usageloop.COUNT}.json"
                                    buffer usage = http GET "${partnerroot}/v1/${continuation_uri}"
                                }
                                if (${HTTP_STATUS_CODE} != 200) {
                                    gosub write_http_error (${HTTP_STATUS_CODE})
                                }

                                # Measure amount of items retrieved
                                var usagecount = $JSON{usage}.[totalCount]
								#print "UsageCount: ${usagecount}"

                                # Extract continuation uri/token when there are more items available above 1000
                                if (${usagecount} == 1000) {
                                    foreach $JSON{usage}.[links].[next].[headers] as this_header {
                                        # Define if the header key is a MS-Continuation token
                                        var hkey = $JSON(this_header).[key]
                                        if (${hkey} == MS-ContinuationToken) {
                                            # Store the continuation token for later use
                                            var continuationToken = $JSON(this_header).[value]
                                            # Store the contintuation uri for later use
                                            var continuation_uri = $JSON{usage}.[links].[next].[uri]
                                            # Leave this iteration of the foreach
                                            exit_loop
                                        }
                                    }
                                }
                                # See if there are items that need to be written to CSV
                                if (${usagecount} == 0) {
                                    # Leave the usage Loop
                                    exit_loop
                                }

                                # Write collected items to CSV
                                foreach $JSON{usage}.[items] as this_item {
                                    csv write_fields "usage" ${customerid} ${subscriptionid}
                                    csv write_fields "usage" $JSON(this_item).[usageStartTime] 
                                    csv write_fields "usage" $JSON(this_item).[usageEndTime]
                                    csv write_fields "usage" $JSON(this_item).[resource].[id] 
                                    csv write_fields "usage" $JSON(this_item).[resource].[name]
                                    csv write_fields "usage" $JSON(this_item).[resource].[category] 
                                    csv write_fields "usage" $JSON(this_item).[resource].[subcategory]
                                    csv write_fields "usage" $JSON(this_item).[quantity] 
                                    csv write_fields "usage" $JSON(this_item).[unit]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[resourceUri]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[location]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[partNumber]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[orderNumber]
                                    csv write_fields "usage" $JSON(this_item).[attributes].[objectType]							
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[tags].[Parent]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[tags].[ExtraCosts]
                                    csv write_fields "usage" $JSON(this_item).[instanceData].[tags].[TenantSpecificCosts]
                                    csv write_fields "usage" $JSON(this_item).[resource].[region]
                                }

                                # Count the collected items and define if we are finnished
                                if (${usagecount} == 1000) {
                                    # Add 1000 items to the total record to trigger the continuation sequence at start of te loop
                                    var totalrecords += 1000
                                } else {
                                    # Count as many as possible
                                    var totalrecords += ${usagecount}
                                    # Leave the usage loop
                                    exit_loop
                                } 
                            }
                        }
                    }
			    }
		    } 

            # get the link and token from the json
			var totalCount = $JSON{customers}.[totalCount]
			var next_link = $JSON{customers}.[links].[next].[uri]
			var continuationToken = $JSON{customers}.[continuationToken]
			
			# skip if we don't have a next_link
			if ("${next_link}" == "EXIVITY_NOT_FOUND") {
				# print "no next link, we can finish."
				exit_loop
			}
			
			# exit if there isn't a new token
			if ("${totalCount}" < 499) {
				# print "no new continuationToken, we can finish"
				exit_loop
			}
			
			# print "this is the total count: ${totalCount}"
			# print "this is the next link: ${next_link}"
			# print "this is the continuationToken: ${continuationToken}"
			var get_token = yes


			# Need to use the continuation token
			# print "Calling continuationToken ... "
			clear http_headers
			set http_header "Accept: application/json"
			set http_header "Authorization: Bearer ${access_token}"
			set http_header "MS-ContinuationToken: ${continuationToken}"
			# print Calling: "${partnerroot}/v1${next_link}"
			buffer customers = http GET "${partnerroot}/v1${next_link}"
			json format {customers}
			save {customers} as "${json_filedir}/${today}_customers_${customers_loop.COUNT}.json"
			
			if (${HTTP_STATUS_CODE} != 200) {
				# print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
				terminate with error
			}


        }
        # Close the csv files to finish off the extraction
        csv close "customers"
        csv close "subscriptions"
        csv close "usage"
		print "|Done||||| Azure Usage collection" 

    } else {
	   	print "|Skipping| Azure Usage collection"
    }

	if (${Collect_Azure_plan} == yes) {

		# Azure Plan path (The CSV is forever growing day by day during the specified month, History collection is not possible on this level.)
		var azureplan_export_file = "${exportdir}/AzurePlan/csp_usage_azureplan_${this_year}${this_month}.csv"
        var azureplan_json_filedir = "${exportdir}/AzurePlan/json"

		if ("${this_month}" == "${MONTH}") {

			# Create azureplan csv
        	csv "azureplan" = "${azureplan_export_file}"
        	csv add_headers "azureplan" partnerId partnerName customerId customerName customerDomainName invoiceNumber productId skuId availabilityId skuName productName publisherName publisherId subscriptionId subscriptionDescription chargeStartDate chargeEndDate usageDate meterType meterCategory meterId meterSubCategory meterName meterRegion unitOfMeasure resourceLocation consumedService resourceGroup resourceUri customerCountry mpnId resellerMpnId chargeType unitPrice quantity unitType billingPreTaxTotal billingCurrency pricingPreTaxTotal pricingCurrency entitlementId entitlementDescription pcToBCExchangeRate pcToBCExchangeRateDate effectiveUnitPrice rateOfPartnerEarnedCredit billingProvider
        	csv fix_headers "azureplan"

			var address = "invoices/unbilled/lineitems?provider=onetime&invoicelineitemtype=usagelineitems&currencycode=${currency}&period=current"
			loop InvoicesLoop {  
				
				# Get the authtoken, output is ${access_token}
        		gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})

				# Setup HTTP request headers
				clear http_headers
				set http_header "Accept: application/json"
				set http_savefile "${azureplan_json_filedir}/azureplan_${this_year}${this_month}_${InvoicesLoop.COUNT}.json"
				set http_header "Authorization: Bearer ${access_token}"  
				# Define if this is the second run with a continuation token
				if (${InvoicesLoop.COUNT} > 1) {
					set http_header "MS-ContinuationToken: ${ContinuationToken}"
				}
				# Extract the invoices
				buffer invoices = http GET "${partnerroot}/v1/${address}"
				if (${HTTP_STATUS_CODE} != 200) {
					gosub write_http_error (${HTTP_STATUS_CODE})
				}

				# Write collected invoice items to CSV
				foreach $JSON{invoices}.[items] as this_item {
					csv write_field azureplan $JSON(this_item).[partnerId]
					csv write_field azureplan $JSON(this_item).[partnerName]
					csv write_field azureplan $JSON(this_item).[customerId]
					csv write_field azureplan $JSON(this_item).[customerName]
					csv write_field azureplan $JSON(this_item).[customerDomainName]
					csv write_field azureplan $JSON(this_item).[invoiceNumber]
					csv write_field azureplan $JSON(this_item).[productId]
					csv write_field azureplan $JSON(this_item).[skuId]
					csv write_field azureplan $JSON(this_item).[availabilityId]
					csv write_field azureplan $JSON(this_item).[skuName]
					csv write_field azureplan $JSON(this_item).[productName]
					csv write_field azureplan $JSON(this_item).[publisherName]
					csv write_field azureplan $JSON(this_item).[publisherId]
					csv write_field azureplan $JSON(this_item).[subscriptionId]
					csv write_field azureplan $JSON(this_item).[subscriptionDescription]
					csv write_field azureplan $JSON(this_item).[chargeStartDate]
					csv write_field azureplan $JSON(this_item).[chargeEndDate]
					csv write_field azureplan $JSON(this_item).[usageDate]
					csv write_field azureplan $JSON(this_item).[meterType]
					csv write_field azureplan $JSON(this_item).[meterCategory]
					csv write_field azureplan $JSON(this_item).[meterId]
					csv write_field azureplan $JSON(this_item).[meterSubCategory]
					csv write_field azureplan $JSON(this_item).[meterName]
					csv write_field azureplan $JSON(this_item).[meterRegion]
					csv write_field azureplan $JSON(this_item).[unitOfMeasure]
					csv write_field azureplan $JSON(this_item).[resourceLocation]
					csv write_field azureplan $JSON(this_item).[consumedService]
					csv write_field azureplan $JSON(this_item).[resourceGroup]
					csv write_field azureplan $JSON(this_item).[resourceUri]
					csv write_field azureplan $JSON(this_item).[customerCountry]
					csv write_field azureplan $JSON(this_item).[mpnId]
					csv write_field azureplan $JSON(this_item).[resellerMpnId]
					csv write_field azureplan $JSON(this_item).[chargeType]
					csv write_field azureplan $JSON(this_item).[unitPrice]
					csv write_field azureplan $JSON(this_item).[quantity]
					csv write_field azureplan $JSON(this_item).[unitType]
					csv write_field azureplan $JSON(this_item).[billingPreTaxTotal]
					csv write_field azureplan $JSON(this_item).[billingCurrency]
					csv write_field azureplan $JSON(this_item).[pricingPreTaxTotal]
					csv write_field azureplan $JSON(this_item).[pricingCurrency]
					csv write_field azureplan $JSON(this_item).[entitlementId]
					csv write_field azureplan $JSON(this_item).[entitlementDescription]
					csv write_field azureplan $JSON(this_item).[pcToBCExchangeRate]
					csv write_field azureplan $JSON(this_item).[pcToBCExchangeRateDate]
					csv write_field azureplan $JSON(this_item).[effectiveUnitPrice]
					csv write_field azureplan $JSON(this_item).[rateOfPartnerEarnedCredit]
					csv write_field azureplan $JSON(this_item).[billingProvider]
				}

				# Collect next URI
				var address = $JSON{invoices}.[links].[next].[uri]
				if ("${address}" != "EXIVITY_NOT_FOUND") {
					var address = $JSON{invoices}.[links].[next].[uri]
					var ContinuationToken = $JSON{invoices}.[continuationToken]
				} else {
					# Finnish up the loop
					csv close "azureplan"
					exit_loop
				}
			}
			discard {invoices}
			print "|Done||||| Current Azure Plan collection"

		} else {
			print "|Skipping| Current month Azure Plan collection, the runmonth is not this month"
		}
        if ("${this_month}" == "${literal_old_month}") {

			# Create azureplan csv
        	csv "azureplan" = "${azureplan_export_file}"
        	csv add_headers "azureplan" partnerId partnerName customerId customerName customerDomainName invoiceNumber productId skuId availabilityId skuName productName publisherName publisherId subscriptionId subscriptionDescription chargeStartDate chargeEndDate usageDate meterType meterCategory meterId meterSubCategory meterName meterRegion unitOfMeasure resourceLocation consumedService resourceGroup resourceUri customerCountry mpnId resellerMpnId chargeType unitPrice quantity unitType billingPreTaxTotal billingCurrency pricingPreTaxTotal pricingCurrency entitlementId entitlementDescription pcToBCExchangeRate pcToBCExchangeRateDate effectiveUnitPrice rateOfPartnerEarnedCredit billingProvider
        	csv fix_headers "azureplan"

			var address = "invoices/unbilled/lineitems?provider=onetime&invoicelineitemtype=usagelineitems&currencycode=${currency}&period=previous"
			loop InvoicesLoop {  

				# Get the authtoken, output is ${access_token}
        		gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})
				
				# Setup HTTP request headers
				clear http_headers
				set http_header "Accept: application/json"
				set http_savefile "${azureplan_json_filedir}/azureplan_${this_year}${this_month}_${InvoicesLoop.COUNT}.json"
				set http_header "Authorization: Bearer ${access_token}"  
				# Define if this is the second run with a continuation token
				if (${InvoicesLoop.COUNT} > 1) {
					set http_header "MS-ContinuationToken: ${ContinuationToken}"
				}
				# Extract the invoices
				buffer invoices = http GET "${partnerroot}/v1/${address}"
				if (${HTTP_STATUS_CODE} != 200) {
					gosub write_http_error (${HTTP_STATUS_CODE})
				}

				# Write collected invoice items to CSV
				foreach $JSON{invoices}.[items] as this_item {
					csv write_field azureplan $JSON(this_item).[partnerId]
					csv write_field azureplan $JSON(this_item).[partnerName]
					csv write_field azureplan $JSON(this_item).[customerId]
					csv write_field azureplan $JSON(this_item).[customerName]
					csv write_field azureplan $JSON(this_item).[customerDomainName]
					csv write_field azureplan $JSON(this_item).[invoiceNumber]
					csv write_field azureplan $JSON(this_item).[productId]
					csv write_field azureplan $JSON(this_item).[skuId]
					csv write_field azureplan $JSON(this_item).[availabilityId]
					csv write_field azureplan $JSON(this_item).[skuName]
					csv write_field azureplan $JSON(this_item).[productName]
					csv write_field azureplan $JSON(this_item).[publisherName]
					csv write_field azureplan $JSON(this_item).[publisherId]
					csv write_field azureplan $JSON(this_item).[subscriptionId]
					csv write_field azureplan $JSON(this_item).[subscriptionDescription]
					csv write_field azureplan $JSON(this_item).[chargeStartDate]
					csv write_field azureplan $JSON(this_item).[chargeEndDate]
					csv write_field azureplan $JSON(this_item).[usageDate]
					csv write_field azureplan $JSON(this_item).[meterType]
					csv write_field azureplan $JSON(this_item).[meterCategory]
					csv write_field azureplan $JSON(this_item).[meterId]
					csv write_field azureplan $JSON(this_item).[meterSubCategory]
					csv write_field azureplan $JSON(this_item).[meterName]
					csv write_field azureplan $JSON(this_item).[meterRegion]
					csv write_field azureplan $JSON(this_item).[unitOfMeasure]
					csv write_field azureplan $JSON(this_item).[resourceLocation]
					csv write_field azureplan $JSON(this_item).[consumedService]
					csv write_field azureplan $JSON(this_item).[resourceGroup]
					csv write_field azureplan $JSON(this_item).[resourceUri]
					csv write_field azureplan $JSON(this_item).[customerCountry]
					csv write_field azureplan $JSON(this_item).[mpnId]
					csv write_field azureplan $JSON(this_item).[resellerMpnId]
					csv write_field azureplan $JSON(this_item).[chargeType]
					csv write_field azureplan $JSON(this_item).[unitPrice]
					csv write_field azureplan $JSON(this_item).[quantity]
					csv write_field azureplan $JSON(this_item).[unitType]
					csv write_field azureplan $JSON(this_item).[billingPreTaxTotal]
					csv write_field azureplan $JSON(this_item).[billingCurrency]
					csv write_field azureplan $JSON(this_item).[pricingPreTaxTotal]
					csv write_field azureplan $JSON(this_item).[pricingCurrency]
					csv write_field azureplan $JSON(this_item).[entitlementId]
					csv write_field azureplan $JSON(this_item).[entitlementDescription]
					csv write_field azureplan $JSON(this_item).[pcToBCExchangeRate]
					csv write_field azureplan $JSON(this_item).[pcToBCExchangeRateDate]
					csv write_field azureplan $JSON(this_item).[effectiveUnitPrice]
					csv write_field azureplan $JSON(this_item).[rateOfPartnerEarnedCredit]
					csv write_field azureplan $JSON(this_item).[billingProvider]
				}

				# Collect next URI
				var address = $JSON{invoices}.[links].[next].[uri]
				if ("${address}" != "EXIVITY_NOT_FOUND") {
					var address = $JSON{invoices}.[links].[next].[uri]
					var ContinuationToken = $JSON{invoices}.[continuationToken]
				} else {
					# Finnish up the loop
					csv close "azureplan"
					exit_loop
				}
			}
			discard {invoices}
			print "|Done||||| Previous Azure Plan collection"

		} else {
			print "|Skipping| Current month Azure Plan collection, the runmonth is not within the Microsoft range"
		}
	} else {
		print "|Skipping| Azure Plan collection"
	}

	if (${Collect_Azure_IUR_Subscription} == yes) {
		print "|Running|| Azure IUR Subscription collection"

		# Set file locations
		var IUR_subscriptions_json_filedir = "${bukkitdir}/IUR_Subscriptions/json"
        var IUR_subscriptions_export_file = "${bukkitdir}/IUR_Subscriptions/${rundate}_csp_subscriptions_IUR.csv"

		# Create CSV file
        csv "IUR_subscriptions" = ${IUR_subscriptions_export_file}
        csv add_headers "IUR_subscriptions" customer_id subscription_id offerId offerName friendlyName quantity unitType creationDate effectiveStartDate commitmentEndDate status autoRenewEnabled billingType contractType
        csv fix_headers "IUR_subscriptions"

		# Get the authtoken, output is ${access_token}
		gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})
		# Get subscriptions
		gosub get_iur_online_subscriptions (${access_token}, ${rundate}, ${IUR_id}, ${IUR_subscriptions_json_filedir}, ${partnerroot})

		# Write data to CSV file
		foreach $JSON{iur_subscriptions}.[items] as this_subscription {
    		csv write_field "IUR_subscriptions" ${IUR_id}
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[id]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[offerId]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[offerName]
			csv write_field "IUR_subscriptions" $JSON(this_subscription).[friendlyName]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[quantity]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[unitType]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[creationDate]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[effectiveStartDate]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[commitmentEndDate]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[status]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[autoRenewEnabled]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[billingType]
    		csv write_field "IUR_subscriptions" $JSON(this_subscription).[contractType]   
    	}
		# Close CSV
		csv close "IUR_subscriptions"

		# Finish IUR subscription collection
		print "|Done||||| Azure IUR Subscription collection"
	} else {
		print "|Skipping| Azure IUR Subscription collection"
	}

	if (${Collect_Azure_IUR_Usage} == yes) {
		print "|Running|| Azure IUR Usage collection"

		# Set file locations
		var json_filedir = "${bukkitdir}/IUR_Usage/json"
        var IUR_usage_export_file = "${bukkitdir}/IUR_Usage/${rundate}_csp_usage_IUR.csv"
		var subscription_filedir = ${IUR_subscriptions_json_filedir}

		# Create csv file
		csv "iur_usage_csv" = ${IUR_usage_export_file}
		csv add_headers "iur_usage_csv" customer_id subscription_id usageStartTime usageEndTime resource_id resource_name resource_category resource_subcategory quantity unit resourceUri location partNumber orderNumber objectType Parent ExtraCosts TenantSpecificCosts region
		csv fix_headers "iur_usage_csv"

		# Get extracted subscriptions
		gosub get_iur_offline_subscriptions (${rundate}, ${IUR_id}, ${subscription_filedir})

		# Iterate through every subscription
		foreach $JSON{iur_subscriptions}.[items] as this_subscription {
			# Take along some items for the CSV:
			var subscription_id = $JSON(this_subscription).[id]

			# Get the authtoken, output is ${access_token}
			gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})

			# Collect the usage for the runday (Returns $JSON{iur_usage})
			gosub get_iur_online_usage (${json_filedir}, ${rundate}, ${IUR_id}, ${access_token}, ${partnerroot}, ${start_time}, ${end_time}, ${subscription_id})

			# Write items to CSV
			foreach $JSON{iur_usage}.[items] as this_item {
				csv write_fields "iur_usage_csv" ${IUR_id} 
				csv write_fields "iur_usage_csv" ${subscription_id}
				csv write_fields "iur_usage_csv" $JSON(this_item).[usageStartTime] 
				csv write_fields "iur_usage_csv" $JSON(this_item).[usageEndTime]
				csv write_fields "iur_usage_csv" $JSON(this_item).[resource].[id] 
				csv write_fields "iur_usage_csv" $JSON(this_item).[resource].[name]
				csv write_fields "iur_usage_csv" $JSON(this_item).[resource].[category] 
				csv write_fields "iur_usage_csv" $JSON(this_item).[resource].[subcategory]
				csv write_fields "iur_usage_csv" $JSON(this_item).[quantity] 
				csv write_fields "iur_usage_csv" $JSON(this_item).[unit]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[resourceUri]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[location]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[partNumber]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[orderNumber]
				csv write_fields "iur_usage_csv" $JSON(this_item).[attributes].[objectType]							
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[tags].[Parent]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[tags].[ExtraCosts]
				csv write_fields "iur_usage_csv" $JSON(this_item).[instanceData].[tags].[TenantSpecificCosts]
				csv write_fields "iur_usage_csv" $JSON(this_item).[resource].[region]
			}
		}
		# Close CSV file
		csv close "iur_usage_csv"
		
		# Finish off IUR Usage extraction
		print "|Done||||| Azure IUR Usage collection"
	} else {
		print "|Skipping| Azure IUR Usage collection"
	}

	if (${Collect_Azure_ratecard} == yes) {
		print "|Running|| Azure ratecard collection"
		# Set file locations
		var ratecard_json_filedir = "${bukkitdir}/Rates/json/${rundate}_ratecard.json"
        var ratecard_export_file = "${bukkitdir}/Rates/Ratecard.csv"

        # Create CSV file
        csv "ratecard_csv" = ${ratecard_export_file}
        csv add_headers "ratecard_csv" meter_id meter_name tags rate_threshold rate category subcategory region unit includedQuantity effectiveDate
        csv fix_headers "ratecard_csv"

		# Get the authtoken, output is ${access_token}
		gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})

		# Get ratecard, output is $JSON{ratecard}
		gosub get_ratecard (${ratecard_json_filedir}, ${currency}, ${partnerroot}, ${region})

		#Write output to CSV
		foreach $JSON{ratecard}.[meters] as this_meter {
			# Build list of tags
			var tags = ""
			foreach $JSON(this_meter).[tags] as this_tag {
				# Build a list of tags separated by |
				if (${this_tag.COUNT} == 1) {
					var tags = "${this_tag.VALUE}"
				} else {
					var tags = "${tags}|${this_tag.VALUE}"
				}
			}
			# Create an output row for each rate threshold
			foreach $JSON(this_meter).[rates] as this_rate {				
				# Render the output row
				csv write_field "ratecard_csv" $JSON(this_meter).[id]
				csv write_field "ratecard_csv" $JSON(this_meter).[name]
				csv write_field "ratecard_csv" ${tags}
				csv write_field "ratecard_csv" ${this_rate.NAME}
				csv write_field "ratecard_csv" ${this_rate.VALUE}
				csv write_field "ratecard_csv" $JSON(this_meter).[category]
				csv write_field "ratecard_csv" $JSON(this_meter).[subcategory]
				csv write_field "ratecard_csv" $JSON(this_meter).[region]
				csv write_field "ratecard_csv" $JSON(this_meter).[unit]
				csv write_field "ratecard_csv" $JSON(this_meter).[includedQuantity]
				csv write_field "ratecard_csv" $JSON(this_meter).[effectiveDate]
			}
		}
		csv close "ratecard_csv"
		
		# Finish ratecard extraction
		print "|Done||||| Azure ratecard collection"
	} else {
		print "|Skipping| Azure ratecard collection"
	}

	if (${Collect_Azure_invoice} == yes) {
		print "|Running|| Azure invoice collection"
		if (${csp_charge_startday} >= ${this_day}) {
			print "|Skipping| Azure invoice collection (Azure usage sensor was still collecting this day, this data will be seen on the next invoice.)"
			if (${this_month} != ${storemonth}) {
				print "|Skipping| Invoice not yet available"
			} else {
			
				# default path variables
				var billing_export_file = "${previousbukkitdir}/Invoice/${previousbukkit_year}${previousbukkit_month}_csp_bill.csv"
				var json_filedir = "${previousbukkitdir}/Invoice/json"

				if (@FILE_EXISTS("${billing_export_file}") && ${overwrite_invoice} != yes) {
					print "|Skipping| Azure invoice collection. (Already have invoice)"
				} else {
					# Get authtoken (Returns: ${access_token})
					gosub get_authtoken (${MyDomain}, ${client_id}, ${secret})

					# # # print "Getting Billing invoice list"
					clear http_headers
					set http_header "Accept: application/json"
					set http_header "Authorization: Bearer ${access_token}"	
					buffer invoices = http GET "${partnerroot}/v1/invoices?size=1&offset=${offset}"
					print offset is ${offset}
					if (${HTTP_STATUS_CODE} != 200) {
						gosub write_http_error (${HTTP_STATUS_CODE})
					}

					csv "billing" = "${billing_export_file}"
					csv add_headers "billing" partnerId customerId customerName mpnId tier2MpnId orderId subscriptionId syndicationPartnerSubscriptionNumber offerId durableOfferId offerName domainName billingCycleType subscriptionName subscriptionDescription subscriptionStartDate subscriptionEndDate chargeStartDate chargeEndDate chargeType unitPrice quantity amount totalOtherDiscount subtotal tax totalForCustomer currency invoiceLineItemType billingProvider detailLineItemId sku includedQuantity overageQuantity listPrice pretaxCharges taxAmount postTaxTotal pretaxEffectiveRate postTaxEffectiveRate partnerName partnerBillableAccountId customerCompanyName invoiceNumber serviceName serviceType resourceGuid resourceName region consumedQuantity
					csv fix_headers "billing"

					foreach $JSON{invoices}.[items] as this_invoice {
						# Define the fields to export to match the headers
						foreach $JSON(this_invoice).[invoiceDetails] as this_item {
							var provider = $JSON(this_item).[billingProvider]
							var LineItemType = $JSON(this_item).[invoiceLineItemType]
							var address = $JSON(this_item).[links].[self].[uri]
							# # # print ${address}
							if (((${provider} == "azure") || (${provider} == "one_time") || (${provider} == "office")) && (${LineItemType} == "billing_line_items")) {
								loop invoices {
									# # # print "Getting Billing invoice for month ${actualmonth}..."
									clear http_headers
									set http_savefile "${json_filedir}/invoiceNumber_${this_invoice.COUNT}_${this_item.COUNT}.json"
									set http_header "Accept: application/json"
									set http_header "Authorization: Bearer ${access_token}"	
									buffer lineItems = http GET "${partnerroot}/v1/${address}"
									if (${HTTP_STATUS_CODE} != 200) {
										# # # print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
										# # # print Exiting
										terminate with error
									}
									
									foreach $JSON{lineItems}.[items] as this_lineItem {
										csv write_field billing $JSON(this_lineItem).[partnerId]
                                        csv write_field billing $JSON(this_lineItem).[customerId]
                                        csv write_field billing $JSON(this_lineItem).[customerName]
                                        csv write_field billing $JSON(this_lineItem).[mpnId]
                                        csv write_field billing $JSON(this_lineItem).[tier2MpnId]
                                        csv write_field billing $JSON(this_lineItem).[orderId]
                                        csv write_field billing $JSON(this_lineItem).[subscriptionId]
                                        csv write_field billing $JSON(this_lineItem).[syndicationPartnerSubscriptionNumber]
                                        csv write_field billing $JSON(this_lineItem).[offerId]
                                        csv write_field billing $JSON(this_lineItem).[durableOfferId]
                                        csv write_field billing $JSON(this_lineItem).[offerName]
                                        csv write_field billing $JSON(this_lineItem).[domainName]
                                        csv write_field billing $JSON(this_lineItem).[billingCycleType]
                                        csv write_field billing $JSON(this_lineItem).[subscriptionName]
                                        csv write_field billing $JSON(this_lineItem).[subscriptionDescription]
                                        csv write_field billing $JSON(this_lineItem).[subscriptionStartDate]
                                        csv write_field billing $JSON(this_lineItem).[subscriptionEndDate]
                                        csv write_field billing $JSON(this_lineItem).[chargeStartDate]
                                        csv write_field billing $JSON(this_lineItem).[chargeEndDate]
                                        csv write_field billing $JSON(this_lineItem).[chargeType]
                                        csv write_field billing $JSON(this_lineItem).[unitPrice]
                                        csv write_field billing $JSON(this_lineItem).[quantity]
                                        csv write_field billing $JSON(this_lineItem).[amount]
                                        csv write_field billing $JSON(this_lineItem).[totalOtherDiscount]
                                        csv write_field billing $JSON(this_lineItem).[subtotal]
                                        csv write_field billing $JSON(this_lineItem).[tax]
                                        csv write_field billing $JSON(this_lineItem).[totalForCustomer]
                                        csv write_field billing $JSON(this_lineItem).[currency]
                                        csv write_field billing $JSON(this_lineItem).[invoiceLineItemType]
                                        csv write_field billing $JSON(this_lineItem).[billingProvider]
                                        csv write_field billing $JSON(this_lineItem).[detailLineItemId]
                                        csv write_field billing $JSON(this_lineItem).[sku]
                                        csv write_field billing $JSON(this_lineItem).[includedQuantity]
                                        csv write_field billing $JSON(this_lineItem).[overageQuantity]
                                        csv write_field billing $JSON(this_lineItem).[listPrice]
                                        csv write_field billing $JSON(this_lineItem).[pretaxCharges]
                                        csv write_field billing $JSON(this_lineItem).[taxAmount]
                                        csv write_field billing $JSON(this_lineItem).[postTaxTotal]
                                        csv write_field billing $JSON(this_lineItem).[pretaxEffectiveRate]
                                        csv write_field billing $JSON(this_lineItem).[postTaxEffectiveRate]
                                        csv write_field billing $JSON(this_lineItem).[partnerName]
                                        csv write_field billing $JSON(this_lineItem).[partnerBillableAccountId]
                                        csv write_field billing $JSON(this_lineItem).[customerCompanyName]
                                        csv write_field billing $JSON(this_lineItem).[invoiceNumber]
                                        csv write_field billing $JSON(this_lineItem).[serviceName]
                                        csv write_field billing $JSON(this_lineItem).[serviceType]
                                        csv write_field billing $JSON(this_lineItem).[resourceGuid]
                                        csv write_field billing $JSON(this_lineItem).[resourceName]
                                        csv write_field billing $JSON(this_lineItem).[region]
                                        csv write_field billing $JSON(this_lineItem).[consumedQuantity]
                                    }

									var address = $JSON{lineItems}.[links].[next].[uri]
									# # # print ${address}
									if ("${address}" != "EXIVITY_NOT_FOUND") {
										var address = $JSON{lineItems}.[links].[next].[uri]
										# # # print The new address is ${address}
									} else {
										# # # print End of the Billing invoice
										exit_loop
									}
								}  
							}
						}
					}
					
					csv close "billing"
									
					print "|Done||||| Azure invoice collection"
				}
			}
		}
	} else {
		print "|Skipping| Azure invoice collection"
	}
	print "------------------------------------------------"
}



















######  ##     ## ########  ########   #######  ##     ## ######## #### ##    ## ########  ######  
##    ## ##     ## ##     ## ##     ## ##     ## ##     ##    ##     ##  ###   ## ##       ##    ## 
##       ##     ## ##     ## ##     ## ##     ## ##     ##    ##     ##  ####  ## ##       ##       
 ######  ##     ## ########  ########  ##     ## ##     ##    ##     ##  ## ## ## ######    ######  
      ## ##     ## ##     ## ##   ##   ##     ## ##     ##    ##     ##  ##  #### ##             ## 
##    ## ##     ## ##     ## ##    ##  ##     ## ##     ##    ##     ##  ##   ### ##       ##    ## 
 ######   #######  ########  ##     ##  #######   #######     ##    #### ##    ## ########  ###### 



#===================  Subroutines ====================#
subroutine get_previousmonth {
  var a = (@DTADD(${SUBARG_1}, -1, MONTH)))
  match b "^([0-9]{8})" ${a}
  if (${b.STATUS} != MATCH) {
    print Could not extract day from the supplied date (${a})
    terminate with error
  } else {
    var previousmonth = ${b.RESULT}
  }
}

subroutine format_date {
    #### Extract the day, month and year fields from today ####
    match day "^[0-9]{6}([0-9]{2})" ${SUBARG_1}
    if (${day.STATUS} != MATCH) {
        # print Could not extract day from the supplied date (${today})
        terminate with error
    } else {
        var day = ${day.RESULT}
    }
    match month "^[0-9]{4}([0-9]{2})[0-9]{2}" ${SUBARG_1}
    if (${day.STATUS} != MATCH) {
        # print Could not extract month from the supplied date (${today})
        terminate with error
    } else {
        var month = ${month.RESULT}
    }
    match year "^([0-9]{4})[0-9]{4}" ${SUBARG_1}
    if (${year.STATUS} != MATCH) {
        # print Could not extract year from the supplied date (${today})
        terminate with error
    } else {
        var year = ${year.RESULT}
    }
}

subroutine get_loopcount {
    var loopcount = (@DATEDIFF(${SUBARG_2}, ${SUBARG_1}))
}

subroutine check_dateargument {
	# Validate that amount of input arguments is as expected
	if (${ARGC} != 2) {
		print "This requires 2 argument, the day to collect usage for, and the date following that day, both in yyyyMMdd format"
		terminate with error
	} else {
		var today = ${ARG_1}
		var tomorrow = ${ARG_2}
	}
	#
	# Validate that to date is not before from date
	if (${ARG_1} > ${ARG_2}) {
	print "TO date cannot be a date that lies before FROM date"
	terminate with error
	}
	# Validate that to date is not the same as from date
	if (${ARG_1} == ${ARG_2}) {
	print "TO date cannot be the same as FROM date"
	terminate with error
	}
	#
	# Check if dates are in correct format
	gosub check_dateformat(${today})
	gosub check_dateformat(${tomorrow})
}

subroutine check_dateformat {
	# Validate the date format is as expected in YYYYMMDD
	match date "^(([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-9]|3[0-1])))" ${SUBARG_1}
	if (${date.STATUS} != MATCH) {
		print Argument error: ${SUBARG_1} is not in YYYYMMDD format
		terminate with error
	}
}

subroutine get_authtoken {
	#Subroutine vars
	#${SUBARG_1} = MyDomain
	#${SUBARG_2} = client_id
	#${SUBARG_3} = secret

    #print "Getting auth Token"
  	set http_body data "grant_type=client_credentials&client_id=${SUBARG_2}&client_secret=${SUBARG_3}&resource=https%3A%2F%2Fgraph.windows.net"
  	set http_header "Content-Type: application/x-www-form-urlencoded"
  	#set http_savefile "${json_filedir}/http_savefile.json"
  	
  	buffer token = http POST "https://login.windows.net/${SUBARG_1}/oauth2/token"
  	if (${HTTP_STATUS_CODE} != 200) {
  		gosub write_http_error (${HTTP_STATUS_CODE})
  	}
  
  	# Create a variable called ${access_token} from the AD token in {token}
  	var access_token = $JSON{token}.[access_token]
  	discard {token}
	uri encode-component access_token
  	# Reset headers as we want to create a new Authorization: header
  	clear http_headers
}

subroutine get_iur_online_subscriptions {
	#Subroutine vars
	#${SUBARG_1} = Access token
	#${SUBARG_2} = Date
	#${SUBARG_3} = IUR_ID
	#${SUBARG_4} = json_filedir
    #${SUBARG_5} = partnerroot

	set http_header "Content-Type: application/x-www-form-urlencoded"
  	set http_header "Authorization: Bearer ${SUBARG_1}"
  	set http_body data "grant_type=jwt_token"
	set http_savefile "${SUBARG_4}/${SUBARG_2}_subscription_${SUBARG_3}.json"

	buffer iur_subscriptions = http GET ${SUBARG_5}/v1/customers/${SUBARG_3}/subscriptions
	if (${HTTP_STATUS_CODE} > 206) {
    	gosub write_http_error (${HTTP_STATUS_CODE})
	}
	var collected_iur_subscriptions = yes
}

subroutine get_iur_offline_subscriptions {
	#Subroutine vars
	#${SUBARG_1} = Date
	#${SUBARG_2} = IUR_ID
	#${SUBARG_3} = json_filedir

	buffer iur_subscriptions = FILE "${SUBARG_3}/${SUBARG_1}_subscription_${SUBARG_2}.json"
	var collected_iur_subscriptions = yes
}

subroutine write_http_error {
	#Subroutine vars
	#${SUBARG_1} = HTTP_STATUS_CODE

	print Got HTTP status ${SUBARG_1}, expected a status of 200
	terminate with error
}

subroutine get_iur_online_usage {
    #Depends on IUR subscriptions
    #Subroutine vars
	#${SUBARG_1} = ${json_filedir}
	#${SUBARG_2} = ${rundate}
	#${SUBARG_3} = ${IUR_id}
    #${SUBARG_4} = ${Access token}
    #${SUBARG_5} = ${partnerroot}
    #${SUBARG_6} = ${start_time}
    #${SUBARG_7} = ${end_time}
    #${SUBARG_8} = ${subscriptionID}

	var subscription_id = ${SUBARG_8}

    # Item for the continuation and a trigger to stop the loop.
    var continuationToken = none
    var totalrecords = 0
    loop iur_usage_extraction_loop {
		if (${iur_usage_extraction_loop.COUNT} == 1) {
			clear http_headers
			set http_header "Accept: application/json"
    		set http_header "Authorization: Bearer ${SUBARG_4}"
            set http_savefile "${SUBARG_1}/${SUBARG_2}_usage_${SUBARG_3}_${subscription_id}.json"

            buffer iur_usage = http GET "${SUBARG_5}/v1/customers/${SUBARG_3}/subscriptions/${SUBARG_8}/utilizations/azure?start_time=${SUBARG_6}&end_time=${SUBARG_7}&granularity=daily&showDetails=true"
       	} 
		else {
			# Use continuation Token
			clear http_headers
			set http_header "Accept: application/json"
			set http_header "Authorization: Bearer ${SUBARG_4}"
			set http_header "MS-ContinuationToken: ${continuationToken}"

			buffer iur_usage = http GET "${SUBARG_5}/v1/${continuation_uri}"
			if (${HTTP_STATUS_CODE} > 206) {
				gosub write_http_error (${HTTP_STATUS_CODE})
			}
		}
		var iur_usage_count = $JSON{iur_usage}.[totalCount]
		if (${iur_usage_count} == 1000) {
			# Extract the continuation token and reuse it next round
			foreach $JSON{usage}.[links].[next].[headers] as this_header {
				var hkey = $JSON(this_header).[key]
				if (${hkey} == MS-ContinuationToken) {
					var continuationToken = $JSON(this_header).[value]
					var continuation_uri = $JSON{usage}.[links].[next].[uri]
					return
				}
			}
		}						
		if (${iur_usage_count} == 0) {
			#print "No consumption found for this customer in the selected time period."
		}
	exit_loop
	}
}

subroutine get_ratecard {
	#Subroutine vars
	#Returns $JSON{ratecard}
	#${SUBARG_1} = ${json_filedir}
	#${SUBARG_2} = ${currency}
	#${SUBARG_3} = ${partnerroot}
	#${SUBARG_4} = ${region}
	

	# Get ratecards
	set http_header "Content-Type: application/x-www-form-urlencoded"
	set http_header "Authorization: Bearer ${access_token}"	
	set http_body data "grant_type=jwt_token"
	set http_savefile ${SUBARG_1}
	buffer ratecard = http GET ${SUBARG_3}/v1/ratecards/azure?currency=${SUBARG_2}&region=${SUBARG_4}
	if (${HTTP_STATUS_CODE} != 200) {
		gosub write_http_error (${HTTP_STATUS_CODE})
	}
}
#================== End Subroutines ==================#

print "|Exiting|| Azure extraction"
print "------------------------------------------------"